---
title: "P/BIO381 Tutorials: Mapping the ExomeSeq data - Day 2"
date: 'February 05, 2020'
output:
  prettydoc::html_pretty:
    theme: cayman
fontsize: 18pt
---

# Learning Objectives for 02/05/20

1. To reinforce our understanding of the general work flow or "pipeline" for processing and analyzing ExomeSeq data.
2. To start mapping (a.k.a. aligning) each set of cleaned reads to a reference genome, remove PCR duplicates, sort and index
3. Calculate mapping statistics to assess quality of the result

## (If you needed to) Download the reference genome

The *Picea abies* reference genome is based on Norway spruce (*P. abies*) and is available from [congenie.org](http://congenie.org).


You don't actually need to do this because we already have the file in the directory below.  But for future reference `wget` is a useful command.

```bash
cd /data/project_data/RS_ExomeSeq/ReferenceGenomes/
wget https://.fna
```

The first step is to index the reference genome, but that only needs to be done once.  So we've done this step already, but here's the command.

```
$ bwa index /data/project_data/RS_ExomeSeq/ReferenceGenomes/Pabies1.0-genome_reduced.fa
```

## Mapping cleaned and trimmed reads against the reference genome

Now that we have cleaned and trimmed read pairs, we're ready to map them against the reference genome.  

* We'll be using a reduced reference genome based on selecting only those scaffolds of the full genome reference that contain at least one bait.  We've placed it on our server here:

`/data/project_data/RS_ExomeSeq/ReferenceGenomes/Pabies1.0-genome_reduced.fa`


* We'll use the program [bwa](https://github.com/lh3/bwa), which is a very efficient and very well vetted read mapper.  Lots of others exist and can be useful to explore for future datasets.  We tried several, and for our exome data, bwa seems to be the best

* We are going to write a bash script together that calls the R1 and R2 reads for each individual in our population, and uses the bwa-mem algorithm to map reads to the reference genome.  The resulting output will be a sam file alignment.  The basic bwa command we'll use is:

```
bwa mem -t 1 -M -a ${ref} ${forward} ${reverse} > ${output}/BWA/${name}.sam

```
where 
```
-t 1 is the number of threads, or computer cpus to use (in this case, just 1)
-M labels a read with a special flag if its mapping is split across >1 contig
-a keeps alignments involving unpaired reads
${ref} specifies the path and filename for the reference genome
${forward} specifies the path and filename for the cleaned and trimmed R1 reads 
${reverse} specifies the path and filename for the cleaned and trimmed R2 reads 
>${output}/BWA/${name}.sam  directs the .sam file to be saved into a directory called BWA
```

Other bwa options detailed here:  [bwa manual page](http://bio-bwa.sourceforge.net/bwa.shtml)

Let's write a bash script for just the read mapping to the reference genome.  We can test this out using one sample (individual) at a time, and then once the syntax is good and the bugs all worked out, we can scale this up to all the inds in our popuations.

Part of our approach involves specifying the population of interest and the paths to the input and output directories.  We can do this by specifying variables in bash, like so:

```



```


After mapping, our next steps (with basic syntax) are to:
1. Convert our sam files to the more efficient binary version (bam) and sort them
+ `sambamba-0.7.1-linux-static view -S --format=bam file.sam -o file.bam`

2. Get rid of any PCR duplicate sequences (why are these a problem?) and re-sort after removing dups
+ `sambamba-0.7.1-linux-static markdup -r -t 1 file.bam file.rmdup.bam`
+ `samtools sort file.rmdup.bam -o file.sorted.rmdup.bam`

3. Get some stats on how well the mapping worked 
+ `samtools flagstat file.sorted.rmdup.bam | awk 'NR>=5&&NR<=13 {print $1}' | column -x` 
+ `samtools depth file.sorted.rmdup.bam | awk '{sum+=$3} END {print sum/NR}`

Let's write these steps into separate bash files, combining (1) and (2) into one script called `process_bam.sh` and (3) into another script called `bam_stats.sh`

Last step, we're going to put these scripts altogether into a "wrapper" that will exectue each of them one after the other, and work for us while we're off getting a coffee or sleeping.  :)  I'll show you how to code this together in class.


To accomplish all of this, we'll use a combination of two new programs:  [samtools](https://github.com/samtools/samtools) and [sambamba](https://lomereiter.github.io/sambamba/).  Samtools was writtend by Heng Li, the same person who wrote bwa, and is a powerful tool for manipulating sam/bam files.  Sambamba is derived from samtools, and has been re-coded to increase efficiency (speed).  We'll use them both at different steps.


Once your wrapper script is ready, you're going to want to start a `screen`.  The `screen` command initiates a new shell window that won't interupt or stop your work if you close your computer, log off the server, or leave the UVM network.  Anytime you're running long jobs, you definiteily want to use `screen`.

Using it is easy.  Just type `screen` followed by <Enter>.  It will take you to a new empyt terminal. You can then start your wrapper bash script and see that it starts running.  Once everything looks good, you have to detach from the screen by typing Ctrl-A + Ctrl-D.  If you don't do this, you'll lose your work!

When you're ready to check back on the progress of your program, you can recover your screen by typing `screen -r`.  That'll re-attach you back to your program!



## Map your reads to the reference transcriptome

We'll use the program `bwa` to map our reads to the reference transcriptome.  The manual can be found [here](http://bio-bwa.sourceforge.net/bwa.shtml).



This fill generate 5 indexing files that all start with OTAU.fna in the ```/data/project_data/beetles/reference/``` directory.  You'll need this path to the reference index files in the mapping command below.

Your first step is to map your cleaned reads using the `bwa mem` command.

```bash
bwa mem <ref.fa> <read1.fq> <read2.fq> > <aln-pe.sam> # you fill in the inputs and outputs!
```

Hint: Don't forget the PATHs to your files!


## You’ve made a Sequence AlignMent (SAM) file!

### Let's take a look!  Try `head` and `tail`.

```bash
tail -n 100 YOURFILENAME.sam > tail.sam
vim tail.sam

:set nowrap
```
A SAM file is a tab delimited text file that stores information about the alignment of reads in a FASTQ file to a reference genome or transcriptome. For each read in a FASTQ file, there’s a line in the SAM file that includes

- the read, aka. query, name,
- a FLAG (number with information about mapping success and orientation and whether the read is the left or right read),
- the reference sequence name to which the read mapped
- the leftmost position in the reference where the read mapped
- the mapping quality (Phred-scaled)
- a CIGAR string that gives alignment information (how many bases Match (M), where there’s an Insertion (I) or Deletion (D))
- an ‘=’, mate position, inferred insert size (columns 7,8,9),
- the query sequence and Phred-scaled quality from the FASTQ file (columns 10 and 11),
- then Lots of good information in TAGS at the end, if the read mapped, including whether it is a unique read (XT:A:U), the number of best hits (X0:i:1), the number of suboptimal hits (X1:i:0).

The left (R1) and right (R2) reads alternate through the file. SAM files usually have a header section with general information where each line starts with the ‘@’ symbol. SAM and BAM files contain the same information; SAM is human readable and BAM is in binary code and therefore has a smaller file size.

Find the official Sequence AlignMent file documentation can be found [here](http://samtools.github.io/hts-specs/SAMv1.pdf).

[This BWA man page](http://bio-bwa.sourceforge.net/bwa.shtml) also discusses SAM alignment format and BWA specific optional fields.

- [Some FLAGs to know](http://seqanswers.com/forums/showthread.php?t=17314) - for example what do the numbers in the second column of data mean? [Here’s a SAM FLAG decoder](https://broadinstitute.github.io/picard/explain-flags.html) by the Broad Institute.
- What about the map quality score, MapQ? That’s important! [Here’s a reference](http://www.acgt.me/blog/2014/12/16/understanding-mapq-scores-in-sam-files-does-37-42).

#### How can we get a summary of how well our reads mapped to the reference? 

```bash
samtools flagstat *.sam
```

#### Let’s see how many of our reads map uniquely.

Why is it important to consider whether a read maps uniquely (i.e., to one place in the transcriptome) for gene expression studies?

```
$ grep -c XT:A:U YOURFILENAME.sam 
1177827

$ grep -c X0:i:1 YOURFILENAME.sam
1182952
```

You can check a number of other elements, total number of reads, search for the various flags…

## Extract read counts from the .sam file from each sample

We will use a custom python script (by my friend Dan Barshis and published with the Simple Fool’s Guide to Population Genomics) called **countxpression.py**. This script will take any number of input *.sam files and, for each .sam file, extract the number of reads that map to each gene (i.e. the “counts”). It will also generate a summary output of useful information including proportion of quality read alignments. The script requires 4 input variables: mapqualitythreshold, lengththreshold, outputstatsfilename, anynumberofinputfiles.

```
cd /data/scripts
cp countxpression_pe.py ~/scripts      #or copy to your directory with the .sam file

python countxpression_pe.py 20 35 countstatssummary.txt YOURFILENAME.sam
```

This python script will generate two files: a .txt file you named (3rd argument you passed the script) and a counts .txt file that includes the number of uniquely mapped reads to each gene in our transcriptome.

Below is what the ```*_counts.txt```  should look like:

```
$ head NC_AD4_M3_bwaaln_counts.txt
ContigName  UniqueTotReads  MultiTotReads   totalreadsgoodmapped
OTAU000001-RA   11  207 218
OTAU000002-RA   982 49  1031
OTAU000003-RA   867 0   867
OTAU000004-RA   338 0   338
OTAU000005-RA   154 0   154
OTAU000006-RA   26  0   26
OTAU000007-RA   17  0   17
OTAU000008-RA   1017    55  1072
OTAU000009-RA   1984    0   1984
```

Once we have all the read counts extracted from each .sam file and in one directory, we can stitch them together with some bash scripting!  Then we'll have a data matrix that we can use to analyze global gene expression patterns!